<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2D Spacecraft Prototype - V8.5 (Polished Parts & Nodes)</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; background-color: #101010; color: #e0e0e0; user-select: none; overflow-x: hidden; }
        h1 {color: #e0e0e0;}
        #pageContainer { display: flex; flex-direction: column; align-items: center; width: 100%;}
        #gameAndUiContainer { display: flex; flex-direction: row; align-items: flex-start; gap: 10px; margin-top:10px; }
        #leftPanel { display: flex; flex-direction: column; gap: 10px; align-items: center; }
        #mainContainer { position: relative; }
        #gameCanvas { border: 1px solid #444; touch-action: none; display: block; }
        #insetCanvas { position: absolute; bottom: 10px; left: 10px; width: 150px; height: 150px; border: 1px solid #888; background-color: rgba(0,0,30,0.7); display: none; z-index: 5; }
        #uiOverlay { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 10px; z-index: 10; }
        #stats { padding: 10px; background-color: rgba(51,51,51,0.8); border-radius: 5px; min-width: 300px; text-align: left; font-size: 0.9em; max-height: 130px; overflow-y: auto;}
        .stat-item { margin-bottom: 3px;}
        .stat-label { font-weight: bold; min-width: 100px; display: inline-block;}
        #fuelGaugeContainer { width: 200px; height: 20px; background-color: #555; border: 1px solid #888; border-radius: 3px; overflow: hidden; position:relative; }
        #fuelGaugeBar { width: 100%; height: 100%; background-color: lightgreen; transition: width 0.2s ease-out; }
        #fuelText { position:absolute; top:0; left: 50%; transform: translateX(-50%); color: black; font-size: 0.8em; line-height:20px; pointer-events: none;}
        #controls { margin-top: 10px; padding: 10px; background-color: #333; border-radius: 5px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; width: fit-content; }
        #designSelectorContainer { margin-top: 5px; margin-bottom:5px; }
        button { padding: 8px 12px; font-size: 14px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 3px;}
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #555; color: #aaa; cursor: not-allowed;}
        .control-group { display: flex; gap: 5px; align-items: center;}
        #muteButton { background-color: #ffc107; color: black; }

        #shipBuilderPanel { width: 220px; padding: 10px; background-color: #2a2a2a; border: 1px solid #444; border-radius: 5px; display: flex; flex-direction: column; gap: 10px;}
        #partPalette h3, #stagingArea h3, #stagingStats h4 { margin-top: 0; margin-bottom: 5px; text-align: center; }
        .part-category { margin-bottom: 10px; }
        .part-button { display: block; width: 100%; padding: 8px; margin-bottom: 5px; background-color: #444; border: 1px solid #666; text-align: left; color: #ddd; cursor: grab; }
        .part-button:active { cursor: grabbing; }
        .part-button:hover { background-color: #555; }
        #stagingCanvas { width: 200px; height: 350px; background-color: #383838; border: 1px solid #555; margin: 0 auto; display: block; transition: border-color 0.2s; }
        #stagingCanvas.drag-over { border-color: #00ff00; }
        #builderActions button {width: calc(50% - 5px); margin-top: 5px;}
        #builderActions { display: flex; justify-content: space-between; }
        #stagingStats { font-size: 0.8em; margin-top: 10px; background-color: #333; padding: 5px; border-radius: 3px;}
        #stagingStats p { margin: 2px 0; }
    </style>
</head>
<body>
    <div id="pageContainer">
        <h1>2D Spacecraft - Polished Parts & Nodes (V8.5)</h1>
        
        <div id="gameAndUiContainer">
            <div id="shipBuilderPanel">
                <div id="partPalette">
                    <h3>Part Palette</h3>
                    <div class="part-category">
                        <button class="part-button" draggable="true" data-part-type="pod" data-part-name="Std. Pod">Command Pod</button>
                        <button class="part-button" draggable="true" data-part-type="tank" data-part-name="Med. Tank">Fuel Tank (M)</button>
                        <button class="part-button" draggable="true" data-part-type="engine" data-part-name="Main Engine">Main Engine</button>
                        <button class="part-button" draggable="true" data-part-type="fairing" data-part-name="Payload Fairing">Fairing</button>
                    </div>
                </div>
                <div id="stagingArea">
                    <h3>Staging Area</h3>
                    <canvas id="stagingCanvas"></canvas>
                </div>
                <div id="stagingStats">
                    <h4>Current Build</h4>
                    <p>Total Mass: <span id="stagingMass">0.00</span> kg</p>
                    <p>Total Thrust: <span id="stagingThrust">0.00</span> N</p>
                    <p>Total Œîv (Vac): <span id="stagingDeltaV">0.00</span> m/s</p>
                </div>
                <div id="builderActions">
                    <button id="undoLastPartButton">Undo Part</button>
                    <button id="clearStagingButton">Clear All</button>
                </div>
                <div id="builderActions"> 
                     <button id="launchCurrentBuildButton" style="width:100%;">Launch This Build!</button>
                </div>
                 <div id="designSelectorContainer">
                    <label for="designSelect">Load Template: </label>
                    <select id="designSelect"></select>
                </div>
            </div>

            <div id="leftPanel">
                <div id="mainContainer">
                    <canvas id="gameCanvas"></canvas>
                    <canvas id="insetCanvas"></canvas>
                    <div id="uiOverlay">
                        <div id="stats">
                            <!-- Stats content -->
                        </div>
                        <div id="fuelGaugeContainer">
                            <div id="fuelGaugeBar"></div> 
                            <span id="fuelText">Fuel: 100%</span>
                        </div>
                    </div>
                </div>
                <div id="controls">
                    <button id="launchButton">Launch Selected Template</button>
                    <button id="resetButton">Reset Sim</button>
                    <button id="muteButton">Mute üîá</button>
                    <div class="control-group">
                        <button id="rotateLeftButton" title="Gimbal Left (Q/‚Üê)">‚¨ÖÔ∏è Gimbal</button>
                        <button id="rotateRightButton" title="Gimbal Right (E/‚Üí)">Gimbal ‚û°Ô∏è</button>
                    </div>
                     <div class="control-group">
                        <button id="zoomOutButton" title="Zoom Out (-)">‚ûñ Zoom</button>
                        <button id="zoomInButton" title="Zoom In (+)">‚ûï Zoom</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Constants (most same as V8.4) ---
        const GRAVITATIONAL_CONSTANT_G = 6.67430e-11; const TIME_SCALE = 1; 
        const EARTH_MASS_KG = 5.972e24; const EARTH_RADIUS_M = 6371000; 
        const EARTH_SEA_LEVEL_AIR_DENSITY = 1.225; const EARTH_ATMOSPHERE_SCALE_HEIGHT = 8500; 
        const EARTH_MAX_ATMOSPHERE_ALTITUDE = 100000;
        const DRAG_COEFFICIENT = 0.5; 
        const MAX_ANGULAR_VELOCITY = Math.PI / 2; const BASE_REACTION_WHEEL_TORQUE = 5000; 
        const MAX_GIMBAL_ANGLE_DEG = 7; const GIMBAL_RATE_DEG_S = 15;   
        const SKY_BLUE_COLOR = { r: 135, g: 206, b: 235 }; const SPACE_BLACK_COLOR = { r: 0, g: 0, b: 16 };
        const MIN_CLOUD_ALTITUDE_M = 4000; const MAX_CLOUD_ALTITUDE_M = 10000; 
        const NUM_CLOUD_LAYERS = 2; const CLOUDS_PER_LAYER = 20; 
        const CLOUD_PARALLAX_FACTOR_MIN = 0.3; const CLOUD_PARALLAX_FACTOR_MAX = 0.7; 
        const CLOUD_BASE_SIZE_MIN = 15000; const CLOUD_BASE_SIZE_MAX = 30000;
        const NUM_SURFACE_FEATURES = 200; const MAX_MOUNTAIN_HEIGHT_M = 1500; const MAX_TREE_HEIGHT_M = 30;
        const SURFACE_FEATURE_VISIBILITY_PPM = 0.05; 
        const ORBIT_PATH_VISIBILITY_ALTITUDE_M = 50000; const ORBIT_PATH_VISIBILITY_PPM = 0.001;       
        const ORBIT_PATH_SEGMENTS = 100;
        const SPACECRAFT_INDICATOR_PPM_THRESHOLD = 0.0005; 
        const INSET_VIEW_PPM_THRESHOLD = 0.002;         
        const INSET_VIEW_TARGET_SIZE_PX = 80; 
        const SMOKE_PARTICLES_PER_SECOND_BASE = 20; // Re-adjusted smoke
        const SMOKE_LIFETIME_S_MIN = 45;        
        const SMOKE_LIFETIME_S_MAX = 130;       
        const SMOKE_INITIAL_SIZE_M_MIN = 10;     
        const SMOKE_INITIAL_SIZE_M_MAX = 22;
        const SMOKE_EXHAUST_VELOCITY_FACTOR = 0.28; 
        const MAX_SMOKE_PARTICLES = 380;         
        const ISP_VACUUM_DEFAULT = 300;

        const planet = { /* same as V8.4 */ 
            mass_kg: EARTH_MASS_KG, radius_m: EARTH_RADIUS_M, color: '#3A8D3A', 
            atmosphereColor: 'rgba(173, 216, 230, 0.15)', 
            maxAtmosphereRadius_m: EARTH_RADIUS_M + EARTH_MAX_ATMOSPHERE_ALTITUDE
        };

        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const insetCanvas = document.getElementById('insetCanvas'); const insetCtx = insetCanvas.getContext('2d');
        const stagingCanvas = document.getElementById('stagingCanvas'); const stagingCtx = stagingCanvas.getContext('2d');
        canvas.width = Math.min(window.innerWidth * 0.70 - 20, 800); 
        canvas.height = Math.min(window.innerHeight * 0.70, 600); 
        
        const dom = { /* same as V8.4 */ 
            time: document.getElementById('time'), /* altitude: document.getElementById('altitude'), */
            apoapsis: document.getElementById('apoapsis'), periapsis: document.getElementById('periapsis'),
            /* speed: document.getElementById('speed'), */ angle: document.getElementById('angle'), gimbal: document.getElementById('gimbal'),
            mass: document.getElementById('mass'), thrust: document.getElementById('thrust'), 
            zoomLevel: document.getElementById('zoomLevel'),
            launchButton: document.getElementById('launchButton'), resetButton: document.getElementById('resetButton'),
            muteButton: document.getElementById('muteButton'), 
            designSelect: document.getElementById('designSelect'), 
            rotateLeftButton: document.getElementById('rotateLeftButton'), rotateRightButton: document.getElementById('rotateRightButton'),
            zoomInButton: document.getElementById('zoomInButton'), zoomOutButton: document.getElementById('zoomOutButton'),
            fuelGaugeBar: document.getElementById('fuelGaugeBar'), fuelText: document.getElementById('fuelText'),
            statsPanel: document.getElementById('stats'),
            clearStagingButton: document.getElementById('clearStagingButton'), 
            launchCurrentBuildButton: document.getElementById('launchCurrentBuildButton'),
            undoLastPartButton: document.getElementById('undoLastPartButton'), 
            stagingMass: document.getElementById('stagingMass'), stagingThrust: document.getElementById('stagingThrust'), stagingDeltaV: document.getElementById('stagingDeltaV')
        };

        let spacecraft; let currentShipPartsConfig = []; 
        let simulationState = { /* same as V8.4 */ 
            isLaunched: false, engineActive: false, timeElapsed: 0, lastTimestamp: 0,
            cameraX_m: 0, cameraY_m: 0, currentPixelsPerMeter: 0.05, 
            controlFlags: { rotateLeft: false, rotateRight: false }, landed: true,
            soundMuted: false, currentDesignName: "DefaultOrbiter" 
        };
        let currentDragForceMagnitude = 0, currentAirDensityValue = EARTH_SEA_LEVEL_AIR_DENSITY;
        let apoapsisAGL = 0, periapsisAGL = 0;
        let smokeParticles = []; let cloudLayers = []; let surfaceFeatures = [];
        let audioCtx; let engineSoundOsc, engineSoundGain; let gimbalSoundOsc, gimbalSoundGain;
        let soundInitialized = false; let lastGimbalInputTime = 0;

        function initAudio() { /* same as V8.4 */ if (soundInitialized || !window.AudioContext || simulationState.soundMuted) return; try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); engineSoundOsc = audioCtx.createOscillator(); engineSoundGain = audioCtx.createGain(); engineSoundOsc.type = 'sawtooth'; engineSoundOsc.frequency.setValueAtTime(50, audioCtx.currentTime); engineSoundGain.gain.setValueAtTime(0, audioCtx.currentTime); engineSoundOsc.connect(engineSoundGain).connect(audioCtx.destination); engineSoundOsc.start(); gimbalSoundOsc = audioCtx.createOscillator(); gimbalSoundGain = audioCtx.createGain(); gimbalSoundOsc.type = 'square'; gimbalSoundOsc.frequency.setValueAtTime(300, audioCtx.currentTime); gimbalSoundGain.gain.setValueAtTime(0, audioCtx.currentTime); gimbalSoundOsc.connect(gimbalSoundGain).connect(audioCtx.destination); gimbalSoundOsc.start(); soundInitialized = true; console.log("Audio Initialized"); } catch (e) { console.error("Web Audio API error.", e); } }
        function playEngineSound(active, thrustRatio = 1) { /* same as V8.4 */ if (!soundInitialized || !engineSoundGain || simulationState.soundMuted) { if(engineSoundGain) engineSoundGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01); return; } if (active) { engineSoundGain.gain.setTargetAtTime(0.1 * thrustRatio, audioCtx.currentTime, 0.01); engineSoundOsc.frequency.setTargetAtTime(40 + 60 * thrustRatio, audioCtx.currentTime, 0.1); } else { engineSoundGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1); } }
        function playGimbalSound() { /* same as V8.4 */ if (!soundInitialized || !gimbalSoundGain || simulationState.soundMuted) return; const now = audioCtx.currentTime; if (now - lastGimbalInputTime < 0.2) return; lastGimbalInputTime = now; gimbalSoundGain.gain.setValueAtTime(0.05, now); gimbalSoundGain.gain.setTargetAtTime(0, now + 0.05, 0.02); gimbalSoundOsc.frequency.setValueAtTime(200 + Math.random() * 200, now);  }
        function toggleMute() { /* same as V8.4 */ simulationState.soundMuted = !simulationState.soundMuted; dom.muteButton.textContent = simulationState.soundMuted ? "Unmute  ‡§∏‡•ç‡§™‡•Ä‡§ï‡§∞" : "Mute üîá"; if (simulationState.soundMuted) { if (soundInitialized && engineSoundGain) engineSoundGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01); } else { if (!soundInitialized) initAudio(); if (spacecraft) playEngineSound(simulationState.engineActive, spacecraft.currentThrust_N / (spacecraft.maxThrust_N || 1) ); } }

        class SmokeParticle { /* same as V8.4 */
            constructor(x_m, y_m, vx_ms, vy_ms) { this.x_m = x_m; this.y_m = y_m; this.vx_ms = vx_ms; this.vy_ms = vy_ms; this.lifetime_s = SMOKE_LIFETIME_S_MIN + Math.random() * (SMOKE_LIFETIME_S_MAX - SMOKE_LIFETIME_S_MIN); this.age_s = 0; this.size_m = SMOKE_INITIAL_SIZE_M_MIN + Math.random() * (SMOKE_INITIAL_SIZE_M_MAX - SMOKE_INITIAL_SIZE_M_MIN); const grayScale = 150 + Math.random() * 55; this.initialOpacity = 0.25 + Math.random() * 0.35; this.color = `rgba(${grayScale},${grayScale},${grayScale},${this.initialOpacity.toFixed(2)})`; this.growthFactor = 1.5 + Math.random() * 2.5; }
            update(deltaTime_s) { this.x_m += this.vx_ms * deltaTime_s; this.y_m += this.vy_ms * deltaTime_s; this.age_s += deltaTime_s; const altitude = Math.sqrt(this.x_m**2 + this.y_m**2) - planet.radius_m; if (altitude < EARTH_MAX_ATMOSPHERE_ALTITUDE && altitude > 0) { const particleDragFactor = 0.1 + Math.random() * 0.2; this.vx_ms *= (1 - particleDragFactor * deltaTime_s * (currentAirDensityValue / EARTH_SEA_LEVEL_AIR_DENSITY)); this.vy_ms *= (1 - particleDragFactor * deltaTime_s * (currentAirDensityValue / EARTH_SEA_LEVEL_AIR_DENSITY)); } }
            draw(ctx, camX_m, camY_m, ppm) { if (this.age_s >= this.lifetime_s) return; const viewX_px = (this.x_m - camX_m) * ppm; const viewY_px = (this.y_m - camY_m) * ppm; const currentSize_m = this.size_m * (1 + (this.age_s / this.lifetime_s) * this.growthFactor); const radius_px = Math.max(0.5, (currentSize_m / 2) * ppm); const screenX_px = canvas.width / 2 + viewX_px; const screenY_px = canvas.height / 2 - viewY_px; if (screenX_px + radius_px < -canvas.width || screenX_px - radius_px > canvas.width*2 || screenY_px + radius_px < -canvas.height || screenY_px - radius_px > canvas.height*2) return; let opacityFactor = 0; const fadeInDuration = this.lifetime_s * 0.05; const fadeOutStart = this.lifetime_s * 0.3; if (this.age_s < fadeInDuration) { opacityFactor = this.age_s / fadeInDuration; } else if (this.age_s > fadeOutStart) { opacityFactor = 1 - (this.age_s - fadeOutStart) / (this.lifetime_s - fadeOutStart); } else { opacityFactor = 1; } opacityFactor = Math.max(0, opacityFactor); const opacity = this.initialOpacity * opacityFactor; if (opacity < 0.005) return; const colorParts = this.color.match(/\d+/g).slice(0,3).join(','); ctx.fillStyle = `rgba(${colorParts}, ${opacity.toFixed(3)})`; ctx.beginPath(); ctx.arc(screenX_px, screenY_px, radius_px, 0, 2 * Math.PI); ctx.fill(); }
        }
        
        // --- Part Definitions with Visuals & Attachment Nodes ---
        class Part { 
            constructor(config) { 
                this.type = config.type; this.name = config.name || config.type; 
                this.dryMass_kg = config.dryMass_kg || 0; this.width_m = config.width_m || 1; 
                this.height_m = config.height_m || 1; this.color = config.color || 'gray'; 
                this.cost = config.cost || 0; this.relative_y_m = 0; 
                // Attachment Nodes: { id: string, type: string, position: {x:0, y: % of height}, acceptedTypes: [], size: string }
                // Position y: 0 is bottom of part, 1 is top of part. x: -0.5 is left, 0 is center, 0.5 is right.
                this.attachmentNodes = config.attachmentNodes || [
                    { id: 'top', type: 'stack_top', position: { x: 0, y: 1 }, acceptedTypes: ['stack_bottom'], size: 'medium' },
                    { id: 'bottom', type: 'stack_bottom', position: { x: 0, y: 0 }, acceptedTypes: ['stack_top', 'engine_top'], size: 'medium' }
                ];
            }
            get mass() { return this.dryMass_kg; }
            // Base draw method - can be overridden by specific parts for custom shapes
            draw(ctx, partStackCenterX_px, spacecraftDrawBottomY_px, currentPPM) { 
                const drawWidth_px = this.width_m * currentPPM; 
                const drawHeight_px = this.height_m * currentPPM; 
                const partBottomY_onCanvas_relative = spacecraftDrawBottomY_px - (this.relative_y_m * currentPPM);
                const partTopY_onCanvas_relative = partBottomY_onCanvas_relative - drawHeight_px;
                const partLeftX_onCanvas_relative = partStackCenter_x_px - drawWidth_px / 2; 
                
                ctx.fillStyle = this.color; 
                ctx.fillRect(partLeftX_onCanvas_relative, partTopY_onCanvas_relative, drawWidth_px, drawHeight_px); 
                ctx.strokeStyle = 'black'; 
                ctx.strokeRect(partLeftX_onCanvas_relative, partTopY_onCanvas_relative, drawWidth_px, drawHeight_px); 
            }
        }
        class CommandPod extends Part { 
            constructor(config) { 
                const defaults = {type: 'pod', name:'Pod', color: '#c0c0c0', width_m: 2, height_m: 1.5, dryMass_kg: 500,
                                  attachmentNodes: [{ id: 'bottom', type: 'stack_bottom', position: {x:0, y:0}, acceptedTypes:['stack_top'], size: 'medium' }]};
                super({...defaults, ...config}); 
            } 
            draw(ctx, partStackCenterX_px, spacecraftDrawBottomY_px, currentPPM) {
                const drawWidth_px = this.width_m * currentPPM; 
                const drawHeight_px = this.height_m * currentPPM; 
                const partBottomY_onCanvas_relative = spacecraftDrawBottomY_px - (this.relative_y_m * currentPPM);
                const partTopY_onCanvas_relative = partBottomY_onCanvas_relative - drawHeight_px;
                const partLeftX_onCanvas_relative = partStackCenterX_px - drawWidth_px / 2; 

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(partLeftX_onCanvas_relative, partBottomY_onCanvas_relative);
                ctx.lineTo(partLeftX_onCanvas_relative + drawWidth_px, partBottomY_onCanvas_relative);
                ctx.lineTo(partLeftX_onCanvas_relative + drawWidth_px / 2, partTopY_onCanvas_relative);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'black'; ctx.stroke();
            }
        }
        class FuelTank extends Part { 
            constructor(config) { 
                const defaults = {type: 'tank', name:'Tank', color: '#aabbcc', width_m: 1.8, height_m: 4, dryMass_kg: 150,
                                  attachmentNodes: [
                                      { id: 'top', type: 'stack_top', position: {x:0, y:1}, acceptedTypes:['stack_bottom'], size: 'medium' },
                                      { id: 'bottom', type: 'stack_bottom', position: {x:0, y:0}, acceptedTypes:['stack_top', 'engine_top'], size: 'medium' }
                                  ]};
                super({...defaults, ...config}); 
                this.fuelCapacity_kg = config.fuelCapacity_kg || 1000; 
                this.currentFuel = this.fuelCapacity_kg; 
            } 
            get mass() { return this.dryMass_kg + this.currentFuel; }
            draw(ctx, partStackCenterX_px, spacecraftDrawBottomY_px, currentPPM) { // Rounded rectangle
                const r = Math.min(this.width_m * currentPPM * 0.2, this.height_m * currentPPM * 0.2, 10); // Corner radius
                const x = partStackCenterX_px - (this.width_m * currentPPM) / 2;
                const y = spacecraftDrawBottomY_px - (this.relative_y_m * currentPPM) - (this.height_m * currentPPM);
                const w = this.width_m * currentPPM;
                const h = this.height_m * currentPPM;

                ctx.beginPath();
                ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
                ctx.fillStyle = this.color; ctx.fill();
                ctx.strokeStyle = '#555'; ctx.stroke();
            }
        }
        class Engine extends Part { 
            constructor(config) { 
                const defaults = {type: 'engine', name:'Engine', color: '#505050', width_m: 2.2, height_m: 2, dryMass_kg: 200,
                                  attachmentNodes: [{ id: 'top', type: 'engine_top', position: {x:0, y:1}, acceptedTypes:['stack_bottom'], size: 'medium' }]};
                super({...defaults, ...config}); 
                this.thrust_N = config.thrust_N || 30000; 
                this.fuelConsumptionRate_kg_s = config.fuelConsumptionRate_kg_s || 10; 
                this.isp = config.isp || ISP_VACUUM_DEFAULT; 
                this.isActive = false; 
                this.thrustLimiter = config.thrustLimiter || 1.0; // 0.0 to 1.0
                this.isEngineActiveByUser = true; // For individual toggling
            } 
            get effectiveThrust() { return this.thrust_N * this.thrustLimiter; }
            draw(ctx, partStackCenterX_px, spacecraftDrawBottomY_px, currentPPM) {
                const baseWidth_px = this.width_m * currentPPM; 
                const housingHeight_px = this.height_m * 0.4 * currentPPM;
                const nozzleHeight_px = this.height_m * 0.6 * currentPPM;
                const nozzleExitWidth_px = baseWidth_px * 1.2; // Nozzle wider at exit

                const partBottomY_onCanvas_relative = spacecraftDrawBottomY_px - (this.relative_y_m * currentPPM);
                const housingTopY = partBottomY_onCanvas_relative - this.height_m * currentPPM;
                const housingBottomY = housingTopY + housingHeight_px;
                const housingLeftX = partStackCenterX_px - baseWidth_px / 2;

                // Housing
                ctx.fillStyle = this.color;
                ctx.fillRect(housingLeftX, housingTopY, baseWidth_px, housingHeight_px);
                ctx.strokeStyle = 'black'; ctx.strokeRect(housingLeftX, housingTopY, baseWidth_px, housingHeight_px);
                
                // Nozzle (trapezoid)
                ctx.fillStyle = '#777';
                ctx.beginPath();
                ctx.moveTo(partStackCenterX_px - baseWidth_px / 2, housingBottomY);      // Top-left of nozzle
                ctx.lineTo(partStackCenterX_px + baseWidth_px / 2, housingBottomY);      // Top-right of nozzle
                ctx.lineTo(partStackCenterX_px + nozzleExitWidth_px / 2, housingBottomY + nozzleHeight_px); // Bottom-right of nozzle
                ctx.lineTo(partStackCenterX_px - nozzleExitWidth_px / 2, housingBottomY + nozzleHeight_px); // Bottom-left of nozzle
                ctx.closePath();
                ctx.fill(); ctx.stroke();
            }
        }
        class Fairing extends Part { 
            constructor(config) { 
                const defaults = {type: 'fairing', name:'Fairing', color: '#e0e0e0', width_m: 2.5, height_m: 3, dryMass_kg: 100,
                                  attachmentNodes: [{ id: 'bottom', type: 'stack_bottom', position: {x:0, y:0}, acceptedTypes:['stack_top'], size: 'medium' }]};
                super({...defaults, ...config}); 
            }
            draw(ctx, partStackCenterX_px, spacecraftDrawBottomY_px, currentPPM) {
                const drawWidth_px = this.width_m * currentPPM; 
                const drawHeight_px = this.height_m * currentPPM; 
                const partBottomY_onCanvas_relative = spacecraftDrawBottomY_px - (this.relative_y_m * currentPPM);
                const partTopY_onCanvas_relative = partBottomY_onCanvas_relative - drawHeight_px;
                const partLeftX_onCanvas_relative = partStackCenterX_px - drawWidth_px / 2; 

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(partLeftX_onCanvas_relative, partBottomY_onCanvas_relative); // Bottom-left
                ctx.lineTo(partLeftX_onCanvas_relative + drawWidth_px, partBottomY_onCanvas_relative); // Bottom-right
                // Ogive curve to top point
                ctx.quadraticCurveTo(
                    partLeftX_onCanvas_relative + drawWidth_px, partBottomY_onCanvas_relative - drawHeight_px * 0.7, // Control point right
                    partLeftX_onCanvas_relative + drawWidth_px / 2, partTopY_onCanvas_relative // Top point
                );
                ctx.quadraticCurveTo(
                    partLeftX_onCanvas_relative, partBottomY_onCanvas_relative - drawHeight_px * 0.7, // Control point left
                    partLeftX_onCanvas_relative, partBottomY_onCanvas_relative // Back to bottom-left
                );
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'black'; ctx.stroke();
            }
        }
        
        class Spacecraft { /* same as V8.3 */
            constructor(partsConfigArray) { this.parts = []; this.position_x_m = 0; this.position_y_m = planet.radius_m; this.velocity_x_ms = 0; this.velocity_y_ms = 0; this.angle_rad = 0; this.angularVelocity_rad_s = 0; this.totalMass_kg = 0; this.currentFuel_kg = 0; this.currentThrust_N = 0; this.maxThrust_N = 0; this.logicalStackHeight_m = 0; this.maxWidth_m = 0; this.momentOfInertia_kg_m2 = 1000; this.altitudeAGL_m = 0; this.engineGimbalAngle_rad = 0; this.maxGimbalAngle_rad = MAX_GIMBAL_ANGLE_DEG * Math.PI / 180; this.gimbalRate_rad_s = GIMBAL_RATE_DEG_S * Math.PI / 180; this.initialFuel_kg = 0; partsConfigArray.forEach(partConfig => { let partInstance; switch(partConfig.type) { case 'pod': partInstance = new CommandPod(partConfig); break; case 'tank': partInstance = new FuelTank(partConfig); break; case 'engine': partInstance = new Engine(partConfig); break; case 'fairing': partInstance = new Fairing(partConfig); break; default: console.error("Unknown part type:", partConfig.type); return; } if (partInstance) this.parts.push(partInstance); }); this._reassemble(); }
            _reassemble() { /* same as V8.3 */  this.totalMass_kg = 0; let tempCurrentFuel = 0; this.maxThrust_N = 0; this.logicalStackHeight_m = 0; this.maxWidth_m = 0; let currentStackOffset_m = 0; this.initialFuel_kg = 0; this.parts.forEach(p => { p.relative_y_m = currentStackOffset_m; currentStackOffset_m += p.height_m; this.totalMass_kg += p.mass; if (p.type === 'tank') { tempCurrentFuel += p.currentFuel; this.initialFuel_kg += p.fuelCapacity_kg; } if (p.type === 'engine') this.maxThrust_N += p.effectiveThrust; /* Use effectiveThrust */ if (p.width_m > this.maxWidth_m) this.maxWidth_m = p.width_m; }); this.currentFuel_kg = tempCurrentFuel; if (this.initialFuel_kg === 0) this.initialFuel_kg = 1;  this.logicalStackHeight_m = currentStackOffset_m; this.momentOfInertia_kg_m2 = (this.totalMass_kg * (this.logicalStackHeight_m**2 + this.maxWidth_m**2)) / 12 ; if (this.momentOfInertia_kg_m2 < 100) this.momentOfInertia_kg_m2 = 100; }
            getCrossSectionalArea(velocityAngle_rad) { /* same as V8.3 */ const spacecraftWorldAngle_rad = this.angle_rad; const aoa_rad = Math.atan2(Math.sin(spacecraftWorldAngle_rad - velocityAngle_rad), Math.cos(spacecraftWorldAngle_rad - velocityAngle_rad)); const frontalArea = Math.PI * (this.maxWidth_m / 2)**2; const profileArea = this.maxWidth_m * this.logicalStackHeight_m; return frontalArea * Math.abs(Math.cos(aoa_rad)) + profileArea * Math.abs(Math.sin(aoa_rad)); }
            getCoMOffset_m() { /* same as V8.3 */ if (this.totalMass_kg === 0) return this.logicalStackHeight_m / 2; let weightedHeightSum = 0; this.parts.forEach(p => { const partCenterY = p.relative_y_m + p.height_m / 2; weightedHeightSum += p.mass * partCenterY; }); return weightedHeightSum / this.totalMass_kg; }
            calculateOrbitalParameters() { /* same as V8.3 */ if (this.totalMass_kg <= 0) { apoapsisAGL = 0; periapsisAGL = 0; return; } const r_vec_x = this.position_x_m; const r_vec_y = this.position_y_m; const v_vec_x = this.velocity_x_ms; const v_vec_y = this.velocity_y_ms; const r_mag = Math.sqrt(r_vec_x**2 + r_vec_y**2); const v_mag_sq = v_vec_x**2 + v_vec_y**2; const mu = GRAVITATIONAL_CONSTANT_G * planet.mass_kg; const specificOrbitalEnergy = v_mag_sq / 2 - mu / r_mag; if (specificOrbitalEnergy >= -1e-3) { apoapsisAGL = Infinity; const h_vec_z = r_vec_x * v_vec_y - r_vec_y * v_vec_x; if (mu > 0 && (1 + 2 * specificOrbitalEnergy * h_vec_z**2 / mu**2) >=0 ) { periapsisAGL = (h_vec_z**2 / mu) / (1 + Math.sqrt(1 + 2 * specificOrbitalEnergy * h_vec_z**2 / mu**2)) - planet.radius_m; } else { periapsisAGL = this.altitudeAGL_m; } } else { const semiMajorAxis_a = -mu / (2 * specificOrbitalEnergy); const h_vec_z = r_vec_x * v_vec_y - r_vec_y * v_vec_x; const eccentricity_e_sq = 1 + (2 * specificOrbitalEnergy * h_vec_z**2) / (mu**2); const eccentricity_e = Math.sqrt(Math.max(0, eccentricity_e_sq)); apoapsisAGL = semiMajorAxis_a * (1 + eccentricity_e) - planet.radius_m; periapsisAGL = semiMajorAxis_a * (1 - eccentricity_e) - planet.radius_m; } if(isNaN(apoapsisAGL) || apoapsisAGL < periapsisAGL && apoapsisAGL !== Infinity ) apoapsisAGL = this.altitudeAGL_m > periapsisAGL ? this.altitudeAGL_m : periapsisAGL; if(isNaN(periapsisAGL)) periapsisAGL = this.altitudeAGL_m; }
            draw(targetCtx, targetCanvasWidth, targetCanvasHeight, sfcScreenX_px, sfcScreenY_px, currentPPM, isInsetView = false) { /* same as V8.3 */ targetCtx.save(); targetCtx.translate(sfcScreenX_px, sfcScreenY_px); targetCtx.rotate(this.angle_rad); const comOffset_m = this.getCoMOffset_m(); const comOffset_px = comOffset_m * currentPPM; const partsOriginX_px_local = 0; const partsOriginY_px_local = -comOffset_px; this.parts.forEach(part => { part.draw(targetCtx, partsOriginX_px_local, -partsOriginY_px_local, currentPPM); }); if (this.currentThrust_N > 0) { this.parts.forEach(p => { if (p.type === 'engine' && p.isActive) { const engineBottomY_from_CoM_local_px = -(comOffset_m - p.relative_y_m) * currentPPM; const flameHeight_px = (10 + Math.random() * 15 + (this.currentThrust_N / (this.maxThrust_N||1)) * 20) * Math.max(0.1, currentPPM / (isInsetView ? 0.2 : 0.5) ); const flameWidth_px = p.width_m * currentPPM * 0.8; targetCtx.save(); targetCtx.translate(0, engineBottomY_from_CoM_local_px); targetCtx.rotate(this.engineGimbalAngle_rad); targetCtx.fillStyle = 'orange'; targetCtx.beginPath(); targetCtx.moveTo(-flameWidth_px / 2, 0); targetCtx.lineTo(flameWidth_px / 2, 0); targetCtx.lineTo(0, flameHeight_px); targetCtx.closePath(); targetCtx.fill(); targetCtx.fillStyle = 'yellow'; const iFW = flameWidth_px*0.5, iFH = flameHeight_px*0.6; targetCtx.beginPath(); targetCtx.moveTo(-iFW/2, 0); targetCtx.lineTo(iFW/2, 0); targetCtx.lineTo(0, iFH); targetCtx.closePath(); targetCtx.fill(); targetCtx.restore(); } }); } targetCtx.restore(); }
            updatePhysics(deltaTime_s, masterEngineCommandActive, gimbalLeft, gimbalRight) { /* Modified for individual engine control */ 
                if (deltaTime_s <= 0 || this.totalMass_kg <= 0) return; 
                let currentLocalGravityMagnitude_N = 0; let targetGimbalAngle_rad = 0; 
                if (gimbalLeft) { targetGimbalAngle_rad = -this.maxGimbalAngle_rad; playGimbalSound(); } 
                else if (gimbalRight) { targetGimbalAngle_rad = this.maxGimbalAngle_rad; playGimbalSound(); } 
                if (this.engineGimbalAngle_rad < targetGimbalAngle_rad) { this.engineGimbalAngle_rad = Math.min(targetGimbalAngle_rad, this.engineGimbalAngle_rad + this.gimbalRate_rad_s * deltaTime_s); } 
                else if (this.engineGimbalAngle_rad > targetGimbalAngle_rad) { this.engineGimbalAngle_rad = Math.max(targetGimbalAngle_rad, this.engineGimbalAngle_rad - this.gimbalRate_rad_s * deltaTime_s); } 
                
                let netTorque_Nm = 0; 
                if (gimbalLeft && !masterEngineCommandActive) netTorque_Nm -= BASE_REACTION_WHEEL_TORQUE; 
                if (gimbalRight && !masterEngineCommandActive) netTorque_Nm += BASE_REACTION_WHEEL_TORQUE; 
                
                this.currentThrust_N = 0; // Total current thrust from all active engines
                let totalFuelConsumedThisFrame_kg = 0;
                let activeEnginesThrusting = false;

                this.parts.forEach(p => {
                    if (p.type === 'engine') {
                        if (masterEngineCommandActive && p.isEngineActiveByUser && this.currentFuel_kg > 0) {
                            p.isActive = true; // Mark individual engine as trying to fire
                            const engineActualThrust = p.effectiveThrust; // Thrust after limiter
                            this.currentThrust_N += engineActualThrust;
                            totalFuelConsumedThisFrame_kg += p.fuelConsumptionRate_kg_s * p.thrustLimiter * deltaTime_s; // Consumption scales with limiter
                            activeEnginesThrusting = true;
                        } else {
                            p.isActive = false;
                        }
                    }
                });

                if (activeEnginesThrusting) {
                     if (totalFuelConsumedThisFrame_kg > this.currentFuel_kg) {
                        const fuelFraction = this.currentFuel_kg / totalFuelConsumedThisFrame_kg;
                        // Scale down thrust and consumption for *all* active engines proportionally
                        this.currentThrust_N *= fuelFraction;
                        totalFuelConsumedThisFrame_kg = this.currentFuel_kg;
                        this.parts.forEach(p => { if(p.type === 'engine' && p.isActive) p.isActive = (Math.random() < fuelFraction); /* Simplistic partial shutdown */ });
                    }
                    let fuelToDeduct = totalFuelConsumedThisFrame_kg;
                    for (let i = this.parts.length - 1; i >= 0; i--) { const part = this.parts[i]; if (part.type === 'tank' && part.currentFuel > 0) { const take = Math.min(part.currentFuel, fuelToDeduct); part.currentFuel -= take; this.currentFuel_kg -= take; this.totalMass_kg -= take; fuelToDeduct -= take; if (fuelToDeduct <= 0) break; } }
                    playEngineSound(true, this.currentThrust_N / (this.maxThrust_N || 1));
                } else {
                    playEngineSound(false);
                }

                if (this.currentFuel_kg <= 0) {  this.currentFuel_kg = 0; simulationState.engineActive = false; /* Master switch off */ this.parts.forEach(p => { if (p.type === 'engine') p.isActive = false; }); this.currentThrust_N = 0; playEngineSound(false); } 
                
                // Torque from Gimballed Engine(s) - for simplicity, assume all active engines gimbal together
                // A more complex model would sum torques from each engine based on its position and gimbal
                if (this.currentThrust_N > 0 && activeEnginesThrusting) { 
                    const leverArm_m = this.getCoMOffset_m(); // Simplification: assume thrust acts at bottom of stack
                    const gimbalTorque_Nm = this.currentThrust_N * Math.sin(this.engineGimbalAngle_rad) * leverArm_m; 
                    netTorque_Nm -= gimbalTorque_Nm; 
                } 
                netTorque_Nm -= this.angularVelocity_rad_s * this.momentOfInertia_kg_m2 * 0.8;  
                const angularAcceleration_rad_s2 = netTorque_Nm / this.momentOfInertia_kg_m2; 
                this.angularVelocity_rad_s += angularAcceleration_rad_s2 * deltaTime_s; 
                this.angularVelocity_rad_s = Math.max(-MAX_ANGULAR_VELOCITY, Math.min(MAX_ANGULAR_VELOCITY, this.angularVelocity_rad_s)); 
                this.angle_rad += this.angularVelocity_rad_s * deltaTime_s; 
                
                const effectiveThrustAngle_rad = this.angle_rad + this.engineGimbalAngle_rad; // Overall thrust vector direction
                const thrustForceX_N = this.currentThrust_N * Math.sin(effectiveThrustAngle_rad); 
                const thrustForceY_N = this.currentThrust_N * Math.cos(effectiveThrustAngle_rad); 
                
                // ... (Rest of physics: Gravity, Drag, Ground Interaction, Kinematics - same as V8.3) ...
                const distanceToPlanetCenter_m = Math.sqrt(this.position_x_m**2 + this.position_y_m**2); this.altitudeAGL_m = distanceToPlanetCenter_m - planet.radius_m; let gravityForceX_N = 0, gravityForceY_N = 0; if (distanceToPlanetCenter_m > 1) { currentLocalGravityMagnitude_N = (GRAVITATIONAL_CONSTANT_G * planet.mass_kg * this.totalMass_kg) / (distanceToPlanetCenter_m**2); gravityForceX_N = -currentLocalGravityMagnitude_N * (this.position_x_m / distanceToPlanetCenter_m); gravityForceY_N = -currentLocalGravityMagnitude_N * (this.position_y_m / distanceToPlanetCenter_m);  } currentAirDensityValue = 0; currentDragForceMagnitude = 0; let dragForceX_N = 0, dragForceY_N = 0; if (this.altitudeAGL_m < EARTH_MAX_ATMOSPHERE_ALTITUDE && this.altitudeAGL_m >= 0) { currentAirDensityValue = EARTH_SEA_LEVEL_AIR_DENSITY * Math.exp(-this.altitudeAGL_m / EARTH_ATMOSPHERE_SCALE_HEIGHT); const speed_ms = Math.sqrt(this.velocity_x_ms**2 + this.velocity_y_ms**2); if (speed_ms > 0.01) { const velocityAngleToY_rad = Math.atan2(this.velocity_x_ms, this.velocity_y_ms); const crossSectionalArea_m2 = this.getCrossSectionalArea(velocityAngleToY_rad); currentDragForceMagnitude = 0.5 * currentAirDensityValue * speed_ms**2 * DRAG_COEFFICIENT * crossSectionalArea_m2; dragForceX_N = -currentDragForceMagnitude * (this.velocity_x_ms / speed_ms); dragForceY_N = -currentDragForceMagnitude * (this.velocity_y_ms / speed_ms); } } let netForceX_N_trans = thrustForceX_N + gravityForceX_N + dragForceX_N; let netForceY_N_trans = thrustForceY_N + gravityForceY_N + dragForceY_N;  simulationState.landed = false; if (distanceToPlanetCenter_m <= planet.radius_m + 0.1) {  simulationState.landed = true; const overlap = planet.radius_m - distanceToPlanetCenter_m; const normX = this.position_x_m / distanceToPlanetCenter_m; const normY = this.position_y_m / distanceToPlanetCenter_m; this.position_x_m += normX * overlap; this.position_y_m += normY * overlap; this.altitudeAGL_m = 0; let v_radial = (this.velocity_x_ms * normX) + (this.velocity_y_ms * normY); if (v_radial < 0) { this.velocity_x_ms -= v_radial * normX; this.velocity_y_ms -= v_radial * normY;} const normalForceMagnitudeOnGround = Math.abs(currentLocalGravityMagnitude_N); const frictionCoefficient = 0.8; let frictionMagnitude = frictionCoefficient * normalForceMagnitudeOnGround; const v_tangent_world_x = this.velocity_x_ms - v_radial * normX; const v_tangent_world_y = this.velocity_y_ms - v_radial * normY; const v_tangent_speed = Math.sqrt(v_tangent_world_x**2 + v_tangent_world_y**2); if (v_tangent_speed > 0.01) { const frictionForceApplied_x = -frictionMagnitude * (v_tangent_world_x / v_tangent_speed); const frictionForceApplied_y = -frictionMagnitude * (v_tangent_world_y / v_tangent_speed); const tangental_accel_x = (thrustForceX_N + dragForceX_N) / this.totalMass_kg; const tangental_accel_y = (thrustForceY_N + dragForceY_N) / this.totalMass_kg; const tangental_force_mag = Math.sqrt(tangental_accel_x**2+tangental_accel_y**2) * this.totalMass_kg; if (frictionMagnitude > tangental_force_mag && v_tangent_speed < 0.5) { this.velocity_x_ms = v_radial * normX; this.velocity_y_ms = v_radial * normY;} else { netForceX_N_trans += frictionForceApplied_x; netForceY_N_trans += frictionForceApplied_y; } } const angleSurfaceNormal = Math.atan2(normX, normY); const angleDiff = Math.atan2(Math.sin(this.angle_rad - angleSurfaceNormal), Math.cos(this.angle_rad - angleSurfaceNormal)); if(Math.abs(angleDiff) < Math.PI/4) { this.angularVelocity_rad_s *= 0.5; } } const accelerationX_ms2 = netForceX_N_trans / this.totalMass_kg; const accelerationY_ms2 = netForceY_N_trans / this.totalMass_kg; this.velocity_x_ms += accelerationX_ms2 * deltaTime_s; this.velocity_y_ms += accelerationY_ms2 * deltaTime_s; this.position_x_m += this.velocity_x_ms * deltaTime_s; this.position_y_m += this.velocity_y_ms * deltaTime_s; this._reassemble(); this.calculateOrbitalParameters(); 
                
                if (this.currentThrust_N > 0 && activeEnginesThrusting && smokeParticles.length < MAX_SMOKE_PARTICLES) { 
                    const smokeEmissionRate = SMOKE_PARTICLES_PER_SECOND_BASE * Math.min(1, this.currentThrust_N / (this.maxThrust_N * 0.5 || 1)); 
                    const numParticlesToEmit = Math.max(0, Math.round(smokeEmissionRate * deltaTime_s));
                    const baseExhaustVelocity = 20 + Math.random() * 10; 
                    const spreadAngle = Math.PI / 8; 
                    for (let i = 0; i < numParticlesToEmit; i++) {
                        if (smokeParticles.length >= MAX_SMOKE_PARTICLES) break;
                        const emitX_m = this.position_x_m; const emitY_m = this.position_y_m; 
                        const smokeBaseAngle_rad = effectiveThrustAngle_rad + Math.PI; 
                        const randomAngleOffset = (Math.random() - 0.5) * spreadAngle * 2; 
                        const smokeEmitAngle_rad = smokeBaseAngle_rad + randomAngleOffset;
                        const particle_vx_relative = baseExhaustVelocity * Math.sin(smokeEmitAngle_rad) * SMOKE_EXHAUST_VELOCITY_FACTOR;
                        const particle_vy_relative = baseExhaustVelocity * Math.cos(smokeEmitAngle_rad) * SMOKE_EXHAUST_VELOCITY_FACTOR;
                        const particle_vx_world = this.velocity_x_ms + particle_vx_relative; 
                        const particle_vy_world = this.velocity_y_ms + particle_vy_relative;
                        smokeParticles.push(new SmokeParticle(emitX_m, emitY_m, particle_vx_world, particle_vy_world)); 
                    }
                }
            }
        }
        const spacecraftDesigns = { /* same as V8.3 */
            "DefaultOrbiter": [ { type: 'engine', name:'Main Engine LKO', thrust_N: 250000, fuelConsumptionRate_kg_s: 80, dryMass_kg: 1000, width_m: 2.5, height_m: 2, isp: 310}, { type: 'tank', name:'Medium Tank', fuelCapacity_kg: 10000, dryMass_kg: 1500, width_m: 2.5, height_m: 8 }, { type: 'pod', name:'Orbiter Pod', dryMass_kg: 800, width_m: 2.5, height_m: 2 } ],
            "SmallProbe": [ { type: 'engine', name:'Small Engine', thrust_N: 50000, fuelConsumptionRate_kg_s: 20, dryMass_kg: 200, width_m: 1, height_m: 1, isp: 280}, { type: 'tank', name:'Small Tank', fuelCapacity_kg: 1000, dryMass_kg: 100, width_m: 1, height_m: 2 }, { type: 'fairing', name:'1.2m Fairing', dryMass_kg: 50, width_m: 1.2, height_m: 1.5 }, { type: 'pod', name:'Probe Core', dryMass_kg: 150, width_m: 0.8, height_m: 0.8, color: 'gold' } ],
            "HeavyLifter_Lower": [ { type: 'engine', name:'Heavy Engine', thrust_N: 1000000, fuelConsumptionRate_kg_s: 300, dryMass_kg: 5000, width_m: 4, height_m: 3, isp: 300}, { type: 'tank', name:'Large Tank', fuelCapacity_kg: 50000, dryMass_kg: 5000, width_m: 4, height_m: 15 }, ]
        };
        function populateDesignSelector() { /* same as V8.3 */ for (const designName in spacecraftDesigns) { const option = document.createElement('option'); option.value = designName; option.textContent = designName.replace(/_/g, ' '); dom.designSelect.appendChild(option); } dom.designSelect.value = simulationState.currentDesignName; }
        function generateClouds() { /* same as V8.3 */ cloudLayers = []; for (let layer = 0; layer < NUM_CLOUD_LAYERS; layer++) { const layerClouds = []; const parallax = CLOUD_PARALLAX_FACTOR_MIN + (CLOUD_PARALLAX_FACTOR_MAX - CLOUD_PARALLAX_FACTOR_MIN) * (layer / (NUM_CLOUD_LAYERS -1 || 1)); const layerAltitudeMin = MIN_CLOUD_ALTITUDE_M + (MAX_CLOUD_ALTITUDE_M - MIN_CLOUD_ALTITUDE_M) * (layer / NUM_CLOUD_LAYERS); const layerAltitudeMax = MIN_CLOUD_ALTITUDE_M + (MAX_CLOUD_ALTITUDE_M - MIN_CLOUD_ALTITUDE_M) * ((layer + 1) / NUM_CLOUD_LAYERS); for (let i = 0; i < CLOUDS_PER_LAYER; i++) { const angle = Math.random() * 2 * Math.PI; const alt_m = layerAltitudeMin + Math.random() * (layerAltitudeMax - layerAltitudeMin); const distFromCenter_m = planet.radius_m + alt_m; const x_m = distFromCenter_m * Math.sin(angle); const y_m = distFromCenter_m * Math.cos(angle); const baseSize = CLOUD_BASE_SIZE_MIN + Math.random() * (CLOUD_BASE_SIZE_MAX - CLOUD_BASE_SIZE_MIN); const numPuffs = 4 + Math.floor(Math.random() * 6); const puffs = []; for(let j=0; j<numPuffs; j++) { puffs.push({ dx_m: (Math.random() - 0.5) * baseSize * 0.6, dy_m: (Math.random() - 0.5) * baseSize * 0.3, r_m: baseSize * (0.2 + Math.random() * 0.3) }); } layerClouds.push({ x_m, y_m, puffs, baseAlpha: 0.2 + Math.random() * 0.3 }); } cloudLayers.push({clouds: layerClouds, parallaxFactor: parallax}); } }
        function drawClouds(mainCtx, camX_m, camY_m, ppm) { /* same as V8.3 */ cloudLayers.forEach(layer => { const parallaxOffsetX = camX_m * (1 - layer.parallaxFactor); const parallaxOffsetY = camY_m * (1 - layer.parallaxFactor); layer.clouds.forEach(cloud => { let overallAlpha = cloud.baseAlpha; if (spacecraft && spacecraft.altitudeAGL_m > MAX_CLOUD_ALTITUDE_M + 10000) { overallAlpha *= Math.max(0, 1 - (spacecraft.altitudeAGL_m - (MAX_CLOUD_ALTITUDE_M + 10000)) / 50000); } if (overallAlpha <= 0.01) return; cloud.puffs.forEach(puff => { const puffWorldX = cloud.x_m + puff.dx_m; const puffWorldY = cloud.y_m + puff.dy_m; const viewX_px = (puffWorldX - (camX_m - parallaxOffsetX)) * ppm; const viewY_px = (puffWorldY - (camY_m - parallaxOffsetY)) * ppm; const radius_px = Math.max(1, puff.r_m * ppm * layer.parallaxFactor * 0.5 ); const screenX_px = mainCtx.canvas.width / 2 + viewX_px; const screenY_px = mainCtx.canvas.height / 2 - viewY_px; if (screenX_px + radius_px < 0 || screenX_px - radius_px > mainCtx.canvas.width || screenY_px + radius_px < 0 || screenY_px - radius_px > mainCtx.canvas.height) return; mainCtx.fillStyle = `rgba(235, 235, 250, ${overallAlpha.toFixed(2)})`; mainCtx.beginPath(); mainCtx.arc(screenX_px, screenY_px, radius_px, 0, 2 * Math.PI); mainCtx.fill(); }); }); }); }
        function generateSurfaceFeatures() { /* same as V8.3 */  surfaceFeatures = []; for (let i = 0; i < NUM_SURFACE_FEATURES; i++) { const angle = Math.random() * 2 * Math.PI; const type = Math.random() < 0.3 ? 'mountain' : 'tree';  let featureHeight_m, baseWidth_m; let color; if (type === 'mountain') { featureHeight_m = 100 + Math.random() * MAX_MOUNTAIN_HEIGHT_M; baseWidth_m = featureHeight_m * (1.5 + Math.random()); const gray = 80 + Math.random() * 40; color = `rgb(${gray},${gray},${gray})`; } else { featureHeight_m = 5 + Math.random() * MAX_TREE_HEIGHT_M; baseWidth_m = featureHeight_m * 0.2 + Math.random() * (featureHeight_m * 0.1); const green = 30 + Math.random() * 50; color = `rgb(0, ${green}, 0)`; } surfaceFeatures.push({ angle, type, height_m: featureHeight_m, baseWidth_m, color }); } surfaceFeatures.sort((a, b) => a.angle - b.angle); }
        function drawSurfaceFeatures(ctx, camX_m, camY_m, ppm) { /* same as V8.3 */ if (ppm < SURFACE_FEATURE_VISIBILITY_PPM) return;  const viewAngleWidth = (canvas.width / ppm) / planet.radius_m * 1.5; const cameraAngle = Math.atan2(camX_m, camY_m); surfaceFeatures.forEach(feature => { let angleDiff = Math.abs(feature.angle - cameraAngle); if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;  if (angleDiff > viewAngleWidth / 2) return; const featureBaseX_m = planet.radius_m * Math.sin(feature.angle); const featureBaseY_m = planet.radius_m * Math.cos(feature.angle); const viewX_px = (featureBaseX_m - camX_m) * ppm; const viewY_px = (featureBaseY_m - camY_m) * ppm; const screenX_px = canvas.width / 2 + viewX_px; const screenY_px = canvas.height / 2 - viewY_px;  const height_px = feature.height_m * ppm; const base_px = feature.baseWidth_m * ppm; if (height_px < 1 && base_px < 1) return;  ctx.save(); ctx.translate(screenX_px, screenY_px); ctx.rotate(feature.angle); ctx.fillStyle = feature.color; if (feature.type === 'mountain') { if (base_px > 0.5 && height_px > 0.5) { ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-base_px / 2, -height_px); ctx.lineTo(base_px / 2, -height_px); ctx.closePath(); ctx.fill(); } } else { if (base_px > 0.2 && height_px > 0.5) { const trunkHeight_px = height_px * 0.4; const foliageRadius_px = height_px * 0.6; ctx.fillRect(-base_px / 2, -trunkHeight_px, base_px, trunkHeight_px); ctx.beginPath(); ctx.arc(0, -trunkHeight_px - foliageRadius_px * 0.6, foliageRadius_px, 0, 2 * Math.PI); ctx.fill(); } } ctx.restore(); }); }
        function drawOrbitPath(ctx, camX_m, camY_m, ppm) { /* same as V8.3 */ if (!spacecraft || spacecraft.altitudeAGL_m < ORBIT_PATH_VISIBILITY_ALTITUDE_M && ppm > ORBIT_PATH_VISIBILITY_PPM) return;  if (apoapsisAGL === Infinity || isNaN(apoapsisAGL) || isNaN(periapsisAGL) || spacecraft.totalMass_kg <=0) return;  const mu = GRAVITATIONAL_CONSTANT_G * planet.mass_kg; const r_vec_x = spacecraft.position_x_m; const r_vec_y = spacecraft.position_y_m; const v_vec_x = spacecraft.velocity_x_ms; const v_vec_y = spacecraft.velocity_y_ms; const r_mag = Math.sqrt(r_vec_x**2 + r_vec_y**2); const v_mag_sq = v_vec_x**2 + v_vec_y**2; const specificOrbitalEnergy = v_mag_sq / 2 - mu / r_mag; if (specificOrbitalEnergy >= 0) return;  const h_vec_z = r_vec_x * v_vec_y - r_vec_y * v_vec_x;  const eccentricity_vec_x = (v_mag_sq - mu / r_mag) * r_vec_x / mu - (r_vec_x * v_vec_x + r_vec_y * v_vec_y) * v_vec_x / mu; const eccentricity_vec_y = (v_mag_sq - mu / r_mag) * r_vec_y / mu - (r_vec_x * v_vec_x + r_vec_y * v_vec_y) * v_vec_y / mu; const eccentricity = Math.sqrt(eccentricity_vec_x**2 + eccentricity_vec_y**2); if (eccentricity >= 1) return;  const semiMajorAxis = -mu / (2 * specificOrbitalEnergy); const argOfPeriapsis_rad = Math.atan2(eccentricity_vec_y, eccentricity_vec_x); ctx.strokeStyle = 'rgba(150, 150, 255, 0.5)'; ctx.lineWidth = Math.max(1, 1 / ppm * 0.00001); ctx.beginPath(); for (let i = 0; i <= ORBIT_PATH_SEGMENTS; i++) { const trueAnomaly_rad = (i / ORBIT_PATH_SEGMENTS) * 2 * Math.PI; const r_path = semiMajorAxis * (1 - eccentricity**2) / (1 + eccentricity * Math.cos(trueAnomaly_rad)); const x_perifocal = r_path * Math.cos(trueAnomaly_rad); const y_perifocal = r_path * Math.sin(trueAnomaly_rad); const x_world = x_perifocal * Math.cos(argOfPeriapsis_rad) - y_perifocal * Math.sin(argOfPeriapsis_rad); const y_world = x_perifocal * Math.sin(argOfPeriapsis_rad) + y_perifocal * Math.cos(argOfPeriapsis_rad); const viewX_px = (x_world - camX_m) * ppm; const viewY_px = (y_world - camY_m) * ppm; const screenX_px = canvas.width / 2 + viewX_px; const screenY_px = canvas.height / 2 - viewY_px; if (i === 0) ctx.moveTo(screenX_px, screenY_px); else ctx.lineTo(screenX_px, screenY_px); } ctx.stroke(); ctx.lineWidth = 1;  }
        function drawPlanet(ctx) { /* same as V8.3 */ const viewCenterX_px = canvas.width / 2; const viewCenterY_px = canvas.height / 2; const planetViewX_px = (0 - simulationState.cameraX_m) * simulationState.currentPixelsPerMeter; const planetViewY_px = (0 - simulationState.cameraY_m) * simulationState.currentPixelsPerMeter; const planetScreenX_px = viewCenterX_px + planetViewX_px; const planetScreenY_px = viewCenterY_px - planetViewY_px; const planetRadius_px = planet.radius_m * simulationState.currentPixelsPerMeter; if (planet.maxAtmosphereRadius_m * simulationState.currentPixelsPerMeter > 2) { const atmRadius_px = planet.maxAtmosphereRadius_m * simulationState.currentPixelsPerMeter; ctx.fillStyle = planet.atmosphereColor; ctx.beginPath(); ctx.arc(planetScreenX_px, planetScreenY_px, atmRadius_px, 0, 2 * Math.PI); ctx.fill(); } if (planetRadius_px > 0.5) { ctx.fillStyle = planet.color; ctx.beginPath(); ctx.arc(planetScreenX_px, planetScreenY_px, planetRadius_px, 0, 2 * Math.PI); ctx.fill(); } }
        
        function initSimulation(launchSource = 'template') { /* same as V8.3 */
            const urlParams = new URLSearchParams(window.location.search);
            if (dom.statsPanel) { dom.statsPanel.style.display = (urlParams.get('nostats') === 'true') ? 'none' : 'block';}
            let designToLoad;
            if (launchSource === 'staging' && currentShipPartsConfig.length > 0) { designToLoad = currentShipPartsConfig; console.log("Launching from Staging Area build."); }
            else { const selectedDesignName = dom.designSelect.value || simulationState.currentDesignName; simulationState.currentDesignName = selectedDesignName; designToLoad = spacecraftDesigns[selectedDesignName]; console.log("Launching template:", selectedDesignName); }
            if (!designToLoad || designToLoad.length === 0) { console.error("No design to load or staging area is empty."); if (Object.keys(spacecraftDesigns).length > 0) { designToLoad = spacecraftDesigns[Object.keys(spacecraftDesigns)[0]]; } else { alert("Error: No spacecraft designs available."); return; } }
            spacecraft = new Spacecraft(designToLoad); spacecraft.position_x_m = 0; spacecraft.position_y_m = planet.radius_m; spacecraft.angle_rad = 0; spacecraft.velocity_x_ms = 0; spacecraft.velocity_y_ms = 0; spacecraft.angularVelocity_rad_s = 0; 
            simulationState.isLaunched = false; simulationState.engineActive = false; simulationState.timeElapsed = 0; simulationState.lastTimestamp = 0;
            const comX = spacecraft.position_x_m + spacecraft.getCoMOffset_m() * Math.sin(spacecraft.angle_rad); const comY = spacecraft.position_y_m + spacecraft.getCoMOffset_m() * Math.cos(spacecraft.angle_rad);
            simulationState.cameraX_m = comX; simulationState.cameraY_m = comY; simulationState.controlFlags = { rotateLeft: false, rotateRight: false }; simulationState.landed = true; spacecraft.engineGimbalAngle_rad = 0;
            currentDragForceMagnitude = 0; currentAirDensityValue = EARTH_SEA_LEVEL_AIR_DENSITY; spacecraft.calculateOrbitalParameters(); apoapsisAGL = spacecraft.altitudeAGL_m; periapsisAGL = spacecraft.altitudeAGL_m;
            smokeParticles = []; if (cloudLayers.length === 0) generateClouds(); if (surfaceFeatures.length === 0) generateSurfaceFeatures(); 
            if(dom.launchButton) dom.launchButton.disabled = false; /* dom.launchButton.textContent = "Launch Selected Template"; */ updateStatsDisplay();
            if(launchSource === 'template' || currentShipPartsConfig.length === 0) { const templateToLoadCfg = spacecraftDesigns[simulationState.currentDesignName] || spacecraftDesigns[Object.keys(spacecraftDesigns)[0]]; currentShipPartsConfig = JSON.parse(JSON.stringify(templateToLoadCfg)); }
             drawStagingAreaRocket(); updateStagingStats();
        }

        function drawStagingAreaRocket() { /* same as V8.3 */
            stagingCtx.clearRect(0, 0, stagingCanvas.width, stagingCanvas.height); stagingCtx.fillStyle = '#383838'; stagingCtx.fillRect(0,0, stagingCanvas.width, stagingCanvas.height);
            if (currentShipPartsConfig.length === 0) return; 
            const tempCraft = new Spacecraft(currentShipPartsConfig); 
            const rocketHeight_m = tempCraft.logicalStackHeight_m; const rocketWidth_m = tempCraft.maxWidth_m;
            const maxDim_m = Math.max(rocketHeight_m, rocketWidth_m, 1); 
            const stagingPPM = Math.min( (stagingCanvas.height * 0.95) / rocketHeight_m, (stagingCanvas.width * 0.9) / rocketWidth_m );
            const stagingSfcScreenX = stagingCanvas.width / 2;
            const comOffset_m = tempCraft.getCoMOffset_m(); 
            const craftCenterY_px = stagingCanvas.height / 2; 
            const bottomOffsetY_px = (tempCraft.logicalStackHeight_m - comOffset_m) * stagingPPM;
            const stagingSfcScreenY = craftCenterY_px + bottomOffsetY_px - (stagingCanvas.height * 0.05) ; 
            const originalAngle = tempCraft.angle_rad; tempCraft.angle_rad = 0; 
            tempCraft.draw(stagingCtx, stagingCanvas.width, stagingCanvas.height, stagingSfcScreenX, stagingSfcScreenY, stagingPPM, true);
            tempCraft.angle_rad = originalAngle; 
        }
        function updateStagingStats() { /* same as V8.3 */
            if (currentShipPartsConfig.length === 0) { dom.stagingMass.textContent = "0.00"; dom.stagingThrust.textContent = "0.00"; dom.stagingDeltaV.textContent = "0.00"; return; }
            let totalDryMass = 0; let totalFuelMass = 0; let totalThrust = 0; let minISP = Infinity; 
            currentShipPartsConfig.forEach(partConfig => { totalDryMass += partConfig.dryMass_kg || 0; if (partConfig.type === 'tank') { totalFuelMass += partConfig.fuelCapacity_kg || 0; } if (partConfig.type === 'engine') { totalThrust += partConfig.thrust_N || 0; minISP = Math.min(minISP, partConfig.isp || ISP_VACUUM_DEFAULT); } });
            const wetMass = totalDryMass + totalFuelMass; dom.stagingMass.textContent = `${wetMass.toFixed(2)} (Dry: ${totalDryMass.toFixed(2)})`; dom.stagingThrust.textContent = totalThrust.toFixed(0); 
            const g0 = 9.80665; let deltaV = 0; if (wetMass > totalDryMass && totalDryMass > 0) { deltaV = (minISP === Infinity ? ISP_VACUUM_DEFAULT : minISP) * g0 * Math.log(wetMass / totalDryMass); } dom.stagingDeltaV.textContent = deltaV.toFixed(0);
        }
        function drawHUD(mainCtx) { /* same as V8.3, ensure spacecraft exists */
            if (!spacecraft || !simulationState.isLaunched) return;
            mainCtx.save(); mainCtx.font = "bold 16px Arial"; mainCtx.fillStyle = "rgba(220, 220, 255, 0.9)"; mainCtx.textAlign = "left";
            const altText = `Alt: ${spacecraft.altitudeAGL_m.toFixed(0)} m`; mainCtx.fillText(altText, 10, mainCtx.canvas.height - 30);
            const speed_ms = Math.sqrt(spacecraft.velocity_x_ms**2 + spacecraft.velocity_y_ms**2);
            const speedText = `Spd: ${speed_ms.toFixed(1)} m/s`; mainCtx.fillText(speedText, 10, mainCtx.canvas.height - 10);
            if (speed_ms > 1) { 
                const angleOfVelocity = Math.atan2(spacecraft.velocity_x_ms, spacecraft.velocity_y_ms); 
                const hudCenterX = mainCtx.canvas.width / 2; const hudCenterY = mainCtx.canvas.height / 2;
                const progradeRadius = Math.min(mainCtx.canvas.width, mainCtx.canvas.height) * 0.1; 
                mainCtx.strokeStyle = "rgba(100, 255, 100, 0.9)"; mainCtx.lineWidth = 2; mainCtx.beginPath();
                const markerStartX = hudCenterX + Math.sin(angleOfVelocity) * (progradeRadius - 8);
                const markerStartY = hudCenterY - Math.cos(angleOfVelocity) * (progradeRadius - 8);
                const markerEndX = hudCenterX + Math.sin(angleOfVelocity) * (progradeRadius + 8);
                const markerEndY = hudCenterY - Math.cos(angleOfVelocity) * (progradeRadius + 8);
                mainCtx.moveTo(markerStartX, markerStartY); mainCtx.lineTo(markerEndX, markerEndY);
                const arrowSize = 6;
                mainCtx.lineTo(markerEndX - Math.sin(angleOfVelocity + Math.PI/4) * arrowSize, markerEndY + Math.cos(angleOfVelocity + Math.PI/4) * arrowSize);
                mainCtx.moveTo(markerEndX, markerEndY);
                mainCtx.lineTo(markerEndX - Math.sin(angleOfVelocity - Math.PI/4) * arrowSize, markerEndY + Math.cos(angleOfVelocity - Math.PI/4) * arrowSize);
                mainCtx.stroke();
            }
            mainCtx.restore();
        }
        function updateCamera() { /* same as V8.3 */ if(!spacecraft) return; const comOffset_m = spacecraft.getCoMOffset_m(); const comX = spacecraft.position_x_m + comOffset_m * Math.sin(spacecraft.angle_rad); const comY = spacecraft.position_y_m + comOffset_m * Math.cos(spacecraft.angle_rad); const targetCameraX_m = comX; const targetCameraY_m = comY; const lerpFactor = 0.1; simulationState.cameraX_m += (targetCameraX_m - simulationState.cameraX_m) * lerpFactor; simulationState.cameraY_m += (targetCameraY_m - simulationState.cameraY_m) * lerpFactor; }
        function updateStatsDisplay() {}// /* same as V8.3 */ if(!spacecraft) return;  dom.apoapsis.textContent = apoapsisAGL >= 1e7 ? (apoapsisAGL/1e3).toFixed(0) + " km" : (apoapsisAGL === Infinity ? "Escape" : apoapsisAGL.toFixed(0) + " m"); dom.periapsis.textContent = periapsisAGL >= 1e7 ? (periapsisAGL/1e3).toFixed(0) + " km" : periapsisAGL.toFixed(0) + " m"; dom.angle.textContent = ((spacecraft.angle_rad * 180 / Math.PI)%360).toFixed(2); dom.gimbal.textContent = (spacecraft.engineGimbalAngle_rad * 180 / Math.PI).toFixed(2); dom.mass.textContent = spacecraft.totalMass_kg.toFixed(2); dom.thrust.textContent = spacecraft.currentThrust_N.toFixed(0); dom.zoomLevel.textContent = simulationState.currentPixelsPerMeter.toExponential(1); const fuelPercent = spacecraft.initialFuel_kg > 0 ? (spacecraft.currentFuel_kg / spacecraft.initialFuel_kg) * 100 : 0; dom.fuelGaugeBar.style.width = `${fuelPercent}%`; dom.fuelText.textContent = `Fuel: ${fuelPercent.toFixed(0)}%`; if (fuelPercent < 25) dom.fuelGaugeBar.style.backgroundColor = 'red'; else if (fuelPercent < 50) dom.fuelGaugeBar.style.backgroundColor = 'orange'; else dom.fuelGaugeBar.style.backgroundColor = 'lightgreen'; }
        
        function gameLoop(timestamp) { /* same as V8.3 */  if(!spacecraft && currentShipPartsConfig.length === 0 && !simulationState.isLaunched) { requestAnimationFrame(gameLoop); return; } if(!spacecraft && simulationState.isLaunched) { requestAnimationFrame(gameLoop); return; } const rawDeltaTime_ms = (timestamp - simulationState.lastTimestamp) || 0; simulationState.lastTimestamp = timestamp; const deltaTime_ms = Math.min(rawDeltaTime_ms, 100); const deltaTime_s = (deltaTime_ms / 1000) * TIME_SCALE; if (spacecraft && simulationState.isLaunched && !simulationState.landed) { simulationState.timeElapsed += deltaTime_s; } if (spacecraft && (simulationState.isLaunched || !simulationState.landed)) { spacecraft.updatePhysics(deltaTime_s, simulationState.engineActive, simulationState.controlFlags.rotateLeft, simulationState.controlFlags.rotateRight); } else if (spacecraft && simulationState.landed && simulationState.engineActive){ spacecraft.updatePhysics(deltaTime_s, simulationState.engineActive, simulationState.controlFlags.rotateLeft, simulationState.controlFlags.rotateRight); } updateCamera(); smokeParticles = smokeParticles.filter(p => p.age_s < p.lifetime_s); smokeParticles.forEach(p => p.update(deltaTime_s)); const atmFactor = spacecraft ? Math.max(0, 1 - Math.min(1, spacecraft.altitudeAGL_m / EARTH_MAX_ATMOSPHERE_ALTITUDE)) : 1; const skyR = SPACE_BLACK_COLOR.r + (SKY_BLUE_COLOR.r - SPACE_BLACK_COLOR.r) * atmFactor; const skyG = SPACE_BLACK_COLOR.g + (SKY_BLUE_COLOR.g - SPACE_BLACK_COLOR.g) * atmFactor; const skyB = SPACE_BLACK_COLOR.b + (SKY_BLUE_COLOR.b - SPACE_BLACK_COLOR.b) * atmFactor; ctx.fillStyle = `rgb(${Math.round(skyR)},${Math.round(skyG)},${Math.round(skyB)})`; ctx.fillRect(0, 0, canvas.width, canvas.height); drawOrbitPath(ctx, simulationState.cameraX_m, simulationState.cameraY_m, simulationState.currentPixelsPerMeter);  drawClouds(ctx, simulationState.cameraX_m, simulationState.cameraY_m, simulationState.currentPixelsPerMeter); drawPlanet(ctx); drawSurfaceFeatures(ctx, simulationState.cameraX_m, simulationState.cameraY_m, simulationState.currentPixelsPerMeter); smokeParticles.forEach(p => p.draw(ctx, simulationState.cameraX_m, simulationState.cameraY_m, simulationState.currentPixelsPerMeter)); 
            if(spacecraft) { const comOffset_m = spacecraft.getCoMOffset_m(); const sfcComX_world = spacecraft.position_x_m + comOffset_m * Math.sin(spacecraft.angle_rad); const sfcComY_world = spacecraft.position_y_m + comOffset_m * Math.cos(spacecraft.angle_rad); const sfcComScreenX_main = canvas.width/2 + (sfcComX_world - simulationState.cameraX_m) * simulationState.currentPixelsPerMeter; const sfcComScreenY_main = canvas.height/2 - (sfcComY_world - simulationState.cameraY_m) * simulationState.currentPixelsPerMeter; if (simulationState.currentPixelsPerMeter < SPACECRAFT_INDICATOR_PPM_THRESHOLD) { ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(sfcComScreenX_main, sfcComScreenY_main, 3, 0, 2 * Math.PI); ctx.fill(); ctx.strokeStyle = 'yellow'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(sfcComScreenX_main, sfcComScreenY_main); const speed = Math.sqrt(spacecraft.velocity_x_ms**2 + spacecraft.velocity_y_ms**2); const vectorLength = Math.min(50, speed * 0.1);  ctx.lineTo( sfcComScreenX_main + (spacecraft.velocity_x_ms / Math.max(1,speed)) * vectorLength, sfcComScreenY_main - (spacecraft.velocity_y_ms / Math.max(1,speed)) * vectorLength  ); ctx.stroke(); ctx.lineWidth = 1; } else { spacecraft.draw(ctx, canvas.width, canvas.height, sfcComScreenX_main, sfcComScreenY_main, simulationState.currentPixelsPerMeter); } if (simulationState.currentPixelsPerMeter < INSET_VIEW_PPM_THRESHOLD) { insetCanvas.style.display = 'block'; insetCtx.clearRect(0, 0, insetCanvas.width, insetCanvas.height); const largerCraftDim_m = Math.max(spacecraft.logicalStackHeight_m, spacecraft.maxWidth_m, 1); const insetPPM = INSET_VIEW_TARGET_SIZE_PX / largerCraftDim_m; const insetSfcScreenX = insetCanvas.width / 2;  const insetSfcScreenY = insetCanvas.height / 2; spacecraft.draw(insetCtx, insetCanvas.width, insetCanvas.height, insetSfcScreenX, insetSfcScreenY, insetPPM, true); } else { insetCanvas.style.display = 'none'; } }
            drawHUD(ctx); updateStatsDisplay(); if (spacecraft && simulationState.landed && !simulationState.engineActive && simulationState.isLaunched) { /* dom.launchButton.textContent = "Landed"; */ } requestAnimationFrame(gameLoop); 
        }
        
        // Event Listeners
        if(dom.launchButton) dom.launchButton.addEventListener('click', () => { if(!soundInitialized) initAudio(); initSimulation('template'); if (spacecraft) { simulationState.isLaunched = true; simulationState.landed = false; simulationState.engineActive = spacecraft.currentFuel_kg > 0; dom.launchButton.textContent = simulationState.engineActive ? "Engine Active (TPL)" : (spacecraft.currentFuel_kg > 0 ? "Engine Off (TPL)" : "Out of Fuel (TPL)"); dom.launchButton.disabled = spacecraft.currentFuel_kg <=0 && !simulationState.engineActive; } });
        dom.launchCurrentBuildButton.addEventListener('click', () => { if(!soundInitialized) initAudio(); if (currentShipPartsConfig.length === 0) { alert("Staging area is empty!"); return; } initSimulation('staging'); if (spacecraft) { simulationState.isLaunched = true; simulationState.landed = false; simulationState.engineActive = spacecraft.currentFuel_kg > 0; } });
        dom.resetButton.addEventListener('click', () => { if(!soundInitialized) initAudio(); initSimulation('template'); }); 
        dom.muteButton.addEventListener('click', toggleMute); 
        dom.designSelect.addEventListener('change', (event) => { simulationState.currentDesignName = event.target.value; const selectedDesign = spacecraftDesigns[simulationState.currentDesignName]; if (selectedDesign) { currentShipPartsConfig = JSON.parse(JSON.stringify(selectedDesign)); } else { currentShipPartsConfig = []; } drawStagingAreaRocket(); updateStagingStats(); initSimulation('template'); });
        dom.clearStagingButton.addEventListener('click', () => { currentShipPartsConfig = []; drawStagingAreaRocket(); updateStagingStats(); });
        dom.undoLastPartButton.addEventListener('click', () => { if (currentShipPartsConfig.length > 0) { currentShipPartsConfig.pop(); drawStagingAreaRocket(); updateStagingStats(); }});
        document.addEventListener('keydown', (e) => { /* same as V8.3 */ if(!soundInitialized && (e.key === 'q' || e.key === 'Q' || e.key === 'e' || e.key === 'E' || e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ')) initAudio(); if (e.key === 'q' || e.key === 'Q' || e.key === 'ArrowLeft') simulationState.controlFlags.rotateLeft = true; if (e.key === 'e' || e.key === 'E' || e.key === 'ArrowRight') simulationState.controlFlags.rotateRight = true; if (e.key === '+' || e.key === '=') handleZoomIn(); if (e.key === '-' || e.key === '_') handleZoomOut(); if (e.key === ' ') { e.preventDefault(); if(currentShipPartsConfig.length > 0 && dom.launchCurrentBuildButton.disabled === false) dom.launchCurrentBuildButton.click(); }  });
        document.addEventListener('keyup', (e) => { /* same as V8.3 */ if (e.key === 'q' || e.key === 'Q' || e.key === 'ArrowLeft') simulationState.controlFlags.rotateLeft = false; if (e.key === 'e' || e.key === 'E' || e.key === 'ArrowRight') simulationState.controlFlags.rotateRight = false; });
        const makePressReleaseButton = (buttonElem, flagName) => { /* same as V8.3 */ const action = () => { if(!soundInitialized) initAudio(); simulationState.controlFlags[flagName] = true; }; buttonElem.addEventListener('mousedown', action); buttonElem.addEventListener('mouseup', () => simulationState.controlFlags[flagName] = false); buttonElem.addEventListener('mouseleave', () => simulationState.controlFlags[flagName] = false); buttonElem.addEventListener('touchstart', (e) => { e.preventDefault(); action(); }); buttonElem.addEventListener('touchend', (e) => { e.preventDefault(); simulationState.controlFlags[flagName] = false; }); };
        makePressReleaseButton(dom.rotateLeftButton, 'rotateLeft'); makePressReleaseButton(dom.rotateRightButton, 'rotateRight');
        function handleZoomIn() { if(!soundInitialized) initAudio(); simulationState.currentPixelsPerMeter *= 1.5; if(simulationState.currentPixelsPerMeter > 20) simulationState.currentPixelsPerMeter = 20;}
        function handleZoomOut() { if(!soundInitialized) initAudio(); simulationState.currentPixelsPerMeter /= 1.5; if(simulationState.currentPixelsPerMeter < 1e-7) simulationState.currentPixelsPerMeter = 1e-7; }
        dom.zoomInButton.addEventListener('click', handleZoomIn); dom.zoomOutButton.addEventListener('click', handleZoomOut);
        canvas.addEventListener('wheel', (e) => { if(!soundInitialized) initAudio(); e.preventDefault(); if (e.deltaY < 0) handleZoomIn(); else handleZoomOut(); });
        
        // --- Drag and Drop Setup (same as V8.3, with part name from data attr) ---
        let draggedPartConfig = null;
        document.querySelectorAll('.part-button').forEach(button => {
            button.addEventListener('dragstart', (event) => {
                const partType = event.target.dataset.partType;
                const partName = event.target.dataset.partName || partType.charAt(0).toUpperCase() + partType.slice(1);
                let defaultConfig;
                 switch(partType) { 
                    case 'pod': defaultConfig = { type: 'pod', name: partName, dryMass_kg: 500, width_m: 2, height_m: 1.5, color: 'silver' }; break;
                    case 'tank': defaultConfig = { type: 'tank', name: partName, fuelCapacity_kg: 1000, dryMass_kg: 150, width_m: 1.8, height_m: 4, color: 'lightgreen' }; break;
                    case 'engine': defaultConfig = { type: 'engine', name: partName, thrust_N: 30000, fuelConsumptionRate_kg_s: 10, dryMass_kg: 200, width_m: 2.2, height_m: 2, color: 'darkgray', isp: ISP_VACUUM_DEFAULT }; break;
                    case 'fairing': defaultConfig = { type: 'fairing', name: partName, dryMass_kg: 100, width_m: 2.5, height_m: 3, color: '#f0f0f0' }; break;
                    default: console.error("Unknown part type for drag:", partType); return;
                }
                draggedPartConfig = defaultConfig;
                event.dataTransfer.setData('application/json', JSON.stringify(defaultConfig)); 
                event.dataTransfer.effectAllowed = 'copy';
                console.log("Dragging:", draggedPartConfig.name);
            });
        });
        stagingCanvas.addEventListener('dragover', (event) => { event.preventDefault(); event.dataTransfer.dropEffect = 'copy'; stagingCanvas.classList.add('drag-over'); });
        stagingCanvas.addEventListener('dragenter', (event) => { event.preventDefault(); stagingCanvas.classList.add('drag-over'); });
        stagingCanvas.addEventListener('dragleave', () => { stagingCanvas.classList.remove('drag-over'); });
        stagingCanvas.addEventListener('drop', (event) => {
            event.preventDefault(); stagingCanvas.classList.remove('drag-over');
            let droppedData;
            try { droppedData = JSON.parse(event.dataTransfer.getData('application/json')); } 
            catch (e) { console.warn("Could not parse dropped JSON data", e); }

            if (draggedPartConfig && draggedPartConfig.type === (droppedData && droppedData.type)) { // Prefer our internally stored config if types match
                currentShipPartsConfig.push(JSON.parse(JSON.stringify(draggedPartConfig))); 
            } else if (droppedData && droppedData.type) { // Fallback to transferred data
                currentShipPartsConfig.push(droppedData);
            } else { return; } // No valid data
            
            drawStagingAreaRocket(); updateStagingStats();
            draggedPartConfig = null; 
        });

        populateDesignSelector(); 
        initSimulation('template');       
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>